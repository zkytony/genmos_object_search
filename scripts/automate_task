#!/usr/bin/env python
#
# Automatically interact with a Sloop MOS ROS bridge until task finishes
# This script calls the plan service when an action is successful
# This script will periodically call the plan service - because belief
# update happens all the time, so it's ok to replan (based on current belief).
import time
import rospy
import argparse
import std_msgs.msg as std_msgs
from pomdp_py.utils import typ
from sloop_ros.msg import PlanNextStepActionGoal, PlanNextStepActionResult
from actionlib_msgs.msg import GoalStatus

GOAL_STATUS = ["PENDING",
               "ACTIVE",
               "PREEMPTED",
               "SUCCEEDED",
               "ABORTED",
               "REJECTED",
               "PREEMPTING",
               "RECALLING",
               "RECALLED",
               "LOST"]

class AutomateTask:
    def __init__(self,
                 plan_goal_topic,
                 progress_topic,
                 action_status_topic,
                 max_steps,
                 max_plan_freq=1):
        self.done = False
        self.max_steps = max_steps
        self.step_count = 0
        self.max_plan_freq = max_plan_freq

        self._wait_for_status = False
        self._action_active = False
        self._wait_and_try_again = False

        self._plan_goal_pub = rospy.Publisher(
            plan_goal_topic, PlanNextStepActionGoal, queue_size=10, latch=True)
        self._plan_status_pub = rospy.Subscriber(
            plan_goal_topic.split("/goal")[0] + "/result", PlanNextStepActionResult, self._plan_status_cb)
        self._progress_sub = rospy.Subscriber(
            progress_topic, std_msgs.String, self._progress_cb)
        self._action_status_topic = rospy.Subscriber(
            action_status_topic, GoalStatus, self._action_status_cb)

    def _progress_cb(self, msg):
        rospy.loginfo(typ.info(msg.data))
        if msg.data == "all found":
            self.done = True

    def _action_status_cb(self, status_msg):
        if self._wait_for_status:
            rospy.loginfo(f"{status_msg.goal_id.id} status: {GOAL_STATUS[status_msg.status]}")
            if status_msg.status == GoalStatus.ACTIVE:
                self._action_active = True
                self._wait_for_status = True
            else:
                self._action_active = False
                self._wait_for_status = False

    def _plan_status_cb(self, result_msg):
        rospy.loginfo("Plan service request response: " + GOAL_STATUS[result_msg.status.status])
        if result_msg.status.status == GoalStatus.ABORTED:
            self._wait_for_status = False
            self._wait_and_try_again = True
        elif result_msg.status.status == GoalStatus.SUCCEEDED:
            self.step_count += 1
            self._wait_and_try_again = False

    def run(self):
        rate = rospy.Rate(self.max_plan_freq)
        while not rospy.is_shutdown():
            if self.step_count >= self.max_steps:
                rospy.logwarn("Used up all planning steps. Task not finished.")
                return
            if self.done:
                rospy.loginfo("Task finished!")
                return

            if not (self._wait_for_status or self._action_active):
                self.send_plan_request()

            if self._wait_and_try_again:
                rospy.loginfo("wait and try sending plan request again")
                time.sleep(1.0)
                self.send_plan_request()
                self._wait_and_try_again = False

            rate.sleep()

    def send_plan_request(self):
        if not self._action_active:
            if self.step_count < self.max_steps:
                g = PlanNextStepActionGoal()
                g.header.stamp = rospy.Time.now()
                self._wait_for_status = True
                self._plan_goal_pub.publish(g)
                rospy.loginfo("Published plan goal {}".format(self.step_count))
            else:
                rospy.logwarn("Used up all planning steps.")
        else:
            rospy.logwarn("another action is active. Will not plan right now.")


def main():
    rospy.init_node("automate_task")
    parser = argparse.ArgumentParser(description="Automate SLOOP MOS task on a robot.")
    parser.add_argument("--max-steps", type=int, help="Maximum number of planning steps", default=50)
    args, _ = parser.parse_known_args()

    plan_goal_topic = rospy.get_param("~plan_goal_topic")
    progress_topic = rospy.get_param("~progress_topic")
    action_status_topic = rospy.get_param("~action_status_topic")

    t = AutomateTask(plan_goal_topic,
                     progress_topic,
                     action_status_topic,
                     args.max_steps)
    t.run()


if __name__ == "__main__":
    main()
